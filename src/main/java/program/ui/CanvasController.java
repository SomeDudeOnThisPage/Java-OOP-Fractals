package program.ui;

import javafx.geometry.Insets;
import javafx.scene.Group;
import javafx.scene.control.ScrollPane;
import javafx.scene.input.ScrollEvent;
import javafx.scene.layout.*;
import javafx.scene.paint.Color;
import javafx.scene.transform.Scale;
import program.Program;
import program.ui.elements.ImageLayer;
import javafx.collections.ObservableList;
import javafx.fxml.*;

import java.net.URL;
import java.util.ResourceBundle;

/**
 * The controller for the canvas scene of the program
 * <p>
 *   This class is used to manage updating the drawing of the layers. It also handles the zooming on the canvas
 * </p>
 * <br>
 * @author Robin Buhlmann
 * @version 0.1
 * @see MainController
 */
public class CanvasController implements Initializable
{

  /**
   * The pane that the AnchorPane, which serves as the anchor for the ImageLayers, lies on
   * HBox is used so we have simple access to a center method
   */
  @FXML private HBox canvasBackground;

  /**
   * ScrollPane enclosing the drawn layers
   */
  @FXML private ScrollPane scrollPane;

  /**
   * StackPane used for stacking panes. Who would have thought?
   */
  @FXML private StackPane stackPane;

  /**
   * The actual contents (layers), grouped to easily scale them
   */
  @FXML private Group contentGroup;

  /**
   * The pane that the ImageLayers are children of
   */
  @FXML private AnchorPane canvasAnchor;

  /**
   * Default scaled size of the canvas layers
   */
  int size = 800;

  /**
   * Minimum scaled size of the canvas layers
   */
  int minsize = 500;

  /**
   * Initial zoom factor
   */
  private double zoomFactor = 1;

  /**
   * Current background color
   */
  private Color color;

  /**
   * Re-adds all layers to the canvasAnchor, setting visibility accordingly
   */
  public void update()
  {
    // Remove all children from the canvasAnchor
    canvasAnchor.getChildren().clear();

    // Retrieve the (probably updated) layerList from the ui
    ObservableList<ImageLayer> layers = Program.ui.getLayers();

    // Iterate over the layers, add them and set visible/invisible
    for (int i = layers.size() - 1; i >= 0; i--)
    {
      ImageLayer l = layers.get(i);

      canvasAnchor.getChildren().add(l);

      l.setVisible(l.visible);
    }
  }

  /**
   * Sets the canvas background color
   * @param c color
   */
  public void setBackgroundColor(Color c)
  {
    Program.debug("Setting background color of canvas to: rgb(" + c.getRed() * 255 + "," + c.getGreen() * 255 + ", " + c.getBlue() * 255 + ");");
    this.color = c;
    canvasAnchor.setStyle("-fx-background-color: rgb(" + c.getRed() * 255 + "," + c.getGreen() * 255 + ", " + c.getBlue() * 255 + ");");
  }

  /**
   * Sets a new AnchorSize
   * @param size size
   */
  public void setAnchorSize(int size)
  {
    // PrefSize == Size of the layers' parent AnchorPane
    canvasAnchor.setPrefSize(size, size);
    this.size = size;
  }

  /**
   * Returns the current size of the canvasAnchor
   * @return size
   */
  public int getAnchorSize()
  {
    return size;
  }

  /**
   * The amount the canvas is scaled by with one mouse scroll input
   */
  final double SCALE_DELTA = 1.01;

  /**
   * Zooms the canvas layers
   * @param event The event
   */
  public void onScroll(ScrollEvent event)
  {
    // scaleFactor = SCALE_DELTA -> if deltaY retrieved from event > 0 scale up, if < 0 scale down
    // Shortened expression generated by IntelliJ Idea
    double scaleFactor = (event.getDeltaY() > 0) ? SCALE_DELTA : 1/SCALE_DELTA;

    // Only scale if the transformation would not make the canvasAnchor smaller as the minimum size defined in this class
    // Same applies for maximum size
    if (!(scaleFactor < 1 && canvasAnchor.getBoundsInParent().getHeight() * scaleFactor < minsize))
    {
      canvasAnchor.getTransforms().add(new Scale(scaleFactor, scaleFactor, 0, 0));
    }
  }

  /**
   * Initializes the controllers elements
   * @param url ignored
   * @param resourceBundle ignored
   */
  @Override
  public void initialize(URL url, ResourceBundle resourceBundle)
  {
    // Redirect the scroll panes' scroll events to our onScroll so we do not get the default scroll behaviour of ScrollPane
    scrollPane.addEventFilter(ScrollEvent.ANY, this::onScroll);

    // Update to initially add any already existing ImageLayers in the mainControllers' layer list
    update();
  }

  /**
   * Placeholder
   */
  public CanvasController()
  {
    this.color = Color.WHITE;
  }
}
